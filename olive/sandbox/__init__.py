"""
olive.sandbox.__init__  – final draft
=====================================

High‑level management of the Olive Docker sandbox.

All filesystem locations, session‑IDs and env‑vars are routed through
:pyMod:`olive.env` so the exact same code runs on the host *and* inside the
container.
"""

from __future__ import annotations

import asyncio
import atexit
import datetime as _dt
import hashlib
import json
import os
import re
import shutil
import signal
import subprocess
import tarfile
from contextlib import contextmanager
from pathlib import Path
from tempfile import NamedTemporaryFile

from rich.errors import LiveError
from rich.markup import escape
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

from olive import env
from olive.logger import get_logger
from olive.preferences import prefs
from olive.tasks.models import TaskSpec
from olive.ui import console, console_lock

from olive.sandbox.utils import docker_required, get_container_name, get_mounts

logger = get_logger("sandbox")
ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")


# ──────────────────────────────────────────────────────────────
# Helper: Rich spinner that never explodes
# ──────────────────────────────────────────────────────────────
@contextmanager
def _safe_status(msg: str):
    try:
        with console.status(f"[highlight]{msg}[/highlight]", spinner="dots") as st:
            yield st
    except LiveError:
        # Already inside a live display – fall back to plain text
        print(f"[dim]{msg} …[/dim]")
        yield console


# ──────────────────────────────────────────────────────────────
# Sandbox manager
# ──────────────────────────────────────────────────────────────
class SandboxManager:
    def __init__(self) -> None:
        self.container_name: str | None = None
        self.log_path: Path = env.get_logs_root() / "sandbox.log"  # ensures dir

    # ────────────────────────────────────────────── build phase
    def write_dockerignore(self) -> None:
        sbx_root = env.get_sandbox_root()
        proj_root = env.get_project_root()
        snapshot_dir = sbx_root / ".olive-snapshot"
        sbx_ignore = sbx_root / ".dockerignore"
        proj_ignore = proj_root / ".dockerignore"

        logger.info("Writing .dockerignore → %s", sbx_ignore)
        sbx_root.mkdir(parents=True, exist_ok=True)

        def _rel(p: Path) -> str:
            return str(p.relative_to(proj_root))

        header = [
            "# Generated by Olive",
            f"# {_dt.datetime.now():%Y-%m-%d %H:%M:%S}",
            "# Auto‑generated – DO NOT EDIT\n",
        ]

        base_ignores = [
            "*.db",
            "*.log",
            "*.pyc",
            "*.sqlite3",
            ".DS_Store",
            ".env",
            ".git/",
            ".git/**/*",
            ".venv/",
            ".venv/**/*",
            "__pycache__/",
            "node_modules/",
            "venv/",
            ".olive/",
            ".olive/run/",
        ]

        allow = [
            f"!{_rel(snapshot_dir)}",
            f"!{_rel(sbx_root / 'staging')}",
            f"!{_rel(sbx_root / 'staging' / 'olive')}/**",
            "!.olive/sandbox/entrypoint.sh",
        ]

        extra = prefs.get("context", "exclude", "paths", default=[]) + prefs.get(
            "context", "exclude", "patterns", default=[]
        )

        sbx_ignore.write_text(
            "\n".join(header + sorted(set(base_ignores)) + allow + sorted(extra)) + "\n"
        )
        shutil.copyfile(sbx_ignore, proj_ignore)

    @docker_required
    def build(self, *, force: bool = False) -> None:
        self.write_dockerignore()

        proj_root = env.get_project_root()
        user_root = env.get_user_root()
        sbx_root = env.get_sandbox_root()
        snapshot_dir = sbx_root / ".olive-snapshot"
        backup_dir = snapshot_dir.parent / "old_snapshots"
        backup_dir.mkdir(parents=True, exist_ok=True)

        template = env.get_resource_path("olive.sandbox", "Dockerfile.template")
        dockerfile_path = sbx_root / "Dockerfile"

        cur_hash = self._hash_directory(user_root)
        marker = snapshot_dir / ".snapshot_hash"
        changed = force or not marker.exists() or marker.read_text() != cur_hash

        if changed:
            if snapshot_dir.exists():
                ts = _dt.datetime.now().strftime("%Y%m%d_%H%M%S")
                prev = marker.read_text() if marker.exists() else "unknown"
                archive = backup_dir / f"snapshot_{ts}_{prev}.tar.gz"
                with tarfile.open(archive, "w:gz") as tar:
                    tar.add(snapshot_dir, arcname=".olive-snapshot")
                shutil.rmtree(snapshot_dir)
                logger.info("Backed‑up snapshot → %s", archive)

            shutil.copytree(user_root, snapshot_dir)
            self._disable_sandbox(snapshot_dir / "preferences.yml")
            marker.write_text(cur_hash)

        rendered = self._render_dockerfile(template)
        if (
            changed
            or not dockerfile_path.exists()
            or dockerfile_path.read_text() != rendered
        ):
            dockerfile_path.write_text(rendered)
            shutil.copy(
                env.get_resource_path("olive.sandbox", "entrypoint.sh"),
                sbx_root / "entrypoint.sh",
            )
            logger.info("Dockerfile updated.")

        if not changed and not force:
            logger.info("No rebuild necessary.")
            return

        cmd = [
            "docker",
            "build",
            "-f",
            str(dockerfile_path),
            "-t",
            "olive/sandbox:latest",
            str(proj_root),
        ]
        with _safe_status("Building sandbox image…") as st:
            proc = subprocess.Popen(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
            )  # noqa: S603
            assert proc.stdout
            for line in proc.stdout:
                clean = ANSI_RE.sub("", line).strip()
                if clean:
                    logger.debug("[docker build] %s", clean)
                    with console_lock():
                        st.update(f"[secondary]{escape(clean[:80])}[/secondary]")
            proc.wait()

        if proc.returncode:
            raise RuntimeError("Docker build failed; see log.")
        logger.info("✅ Sandbox image built successfully.")

    # ────────────────────────────────────────────── lifecycle
    @docker_required
    def start(self) -> None:
        if self.is_running():
            logger.info("Sandbox already running.")
            return

        self._ensure_image()

        sid = env.get_session_id() or env.generate_session_id()
        sbx_root = env.get_sandbox_run_root()  # also creates RPC/result dirs
        os.environ["OLIVE_SANDBOX_DIR"] = str(sbx_root)

        self.container_name = get_container_name()

        mode = os.getenv("SANDBOX_MODE") or prefs.get("sandbox", "disk", default="copy")
        mnt_args: list[str] = []
        if mode == "mount":
            for host, cont, ro in get_mounts():
                mnt_args += ["-v", f"{host}:{cont}:{'ro' if ro else 'rw'}"]
        else:
            logger.info("Sandbox running in COPY mode.")

        cmd = [
            "docker",
            "run",
            "-dit",
            "--name",
            self.container_name,
            "-e",
            f"OLIVE_SESSION_ID={sid}",
            "-e",
            f"OLIVE_SANDBOX_DIR=/mnt/project/.olive/run/sbx/{sid}",
            *mnt_args,
            "--workdir",
            "/sandbox",
            "olive/sandbox:latest",
            "daemon",
        ]

        with _safe_status("Starting sandbox…") as st:
            proc = subprocess.Popen(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
            )  # noqa: S603
            assert proc.stdout
            for line in proc.stdout:
                clean = ANSI_RE.sub("", line).strip()
                if clean:
                    logger.debug("[docker run] %s", clean)
                    with console_lock():
                        st.update(f"[secondary]{escape(clean[:80])}[/secondary]")
            proc.wait()

        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, cmd)
        if not self.is_running():
            raise RuntimeError("Sandbox container exited immediately.")
        logger.info("✅ Sandbox container is running.")

    @docker_required
    def stop(self) -> None:
        if not self.is_running():
            return
        logger.info("Stopping sandbox container: %s", self.container_name)
        subprocess.run(
            ["docker", "rm", "-f", self.container_name], stdout=subprocess.DEVNULL
        )
        logger.info("Sandbox stopped.")

    def restart(self) -> None:
        self.stop()
        self.start()

    # ────────────────────────────────────────────── admin
    @docker_required
    def status(self) -> dict:
        if not self.is_running():
            return {"running": False}
        res = subprocess.run(
            [
                "docker",
                "stats",
                "--no-stream",
                "--format",
                "{{.Name}} {{.CPUPerc}} {{.MemUsage}}",
            ],
            capture_output=True,
            text=True,
        )
        for line in res.stdout.strip().splitlines():
            if line.startswith(self.container_name):
                _, cpu, mem = line.split(maxsplit=2)
                return {
                    "running": True,
                    "cpu": cpu,
                    "mem": mem,
                    "name": self.container_name,
                }
        return {"running": True, "name": self.container_name}

    @docker_required
    def logs(self, *, tail: int = 40, follow: bool = False) -> None:
        if not self.is_running():
            print("[yellow]Sandbox is not running.[/yellow]")
            return
        cmd = ["docker", "logs", "--tail", str(tail)]
        if follow:
            cmd.append("--follow")
        cmd.append(self.container_name)
        subprocess.run(cmd)

    # ────────────────────────────────────────────── dispatch
    @docker_required
    def dispatch_task(self, spec: TaskSpec, *, wait: bool = True) -> dict:
        sid = env.get_session_id()
        if not sid:
            raise RuntimeError("dispatch_task called outside sandbox session")

        rpc_dir = env.get_sandbox_rpc_dir()
        result_dir = env.get_tasks_root()

        result_filename = spec.return_id or spec.id
        task_path = env.get_task_file(result_filename)

        # atomic write
        tmp: Path | None = None
        try:
            with NamedTemporaryFile("w", dir=rpc_dir, delete=False, suffix=".tmp") as t:
                json.dump(spec.model_dump(), t, indent=2)
                t.flush()
                os.fsync(t.fileno())
                tmp = Path(t.name)
            tmp.rename(task_path)
        finally:
            if tmp and tmp.exists():
                tmp.unlink(missing_ok=True)

        inside_path = Path("/mnt/project") / task_path.relative_to(
            env.get_project_root()
        )
        res = subprocess.run(
            [
                "docker",
                "exec",
                self.container_name,
                "olive",
                "run-task",
                str(inside_path),
            ],
            capture_output=True,
            text=True,
        )
        if res.returncode:
            raise subprocess.CalledProcessError(
                res.returncode, res.args, res.stdout, res.stderr
            )

        if not wait or spec.return_id is None:
            return {
                "dispatched": True,
                "task_id": spec.id,
                "return_id": spec.return_id,
                "result_path": str(env.get_result_file(result_filename))
            }

        result_path = env.get_result_file(result_filename)
        logger.info("Waiting for result via watchdog: %s", result_path)

        class _Done(FileSystemEventHandler):
            def __init__(self) -> None:
                self.evt = asyncio.Event()

            def on_created(self, event):  # type: ignore[override]
                if Path(event.src_path) == result_path:
                    self.evt.set()

        h = _Done()
        ob = Observer()
        ob.schedule(h, result_dir, recursive=False)
        ob.start()
        try:
            while not result_path.exists():
                if h.evt.wait(1):
                    break
        finally:
            ob.stop()
            ob.join()

        logger.info("✅ Result ready: %s", result_path)
        return json.loads(result_path.read_text())

    @docker_required
    async def dispatch_task_async(self, spec: TaskSpec) -> dict:
        """
        Legacy async wrapper — identical behaviour: run the blocking
        dispatch in a background thread so callers may `await` it.
        """
        return await asyncio.to_thread(self.dispatch_task, spec)

    @docker_required
    def dispatch_tool(self, toolname: str, args: list[str]) -> dict:
        if not self.is_running():
            raise RuntimeError("Sandbox is not running.")

        from shlex import quote

        cmdline = f"!!{toolname} {' '.join(quote(a) for a in args)}".strip()
        logger.info("Sending to sandbox daemon via tmux: %s", cmdline)

        target = f"olive-{env.get_session_id()}"
        res = subprocess.run(
            [
                "docker",
                "exec",
                self.container_name,
                "tmux",
                "send-keys",
                "-t",
                target,
                cmdline,
                "C-m",
            ],
            capture_output=True,
            text=True,
        )

        if res.stdout.strip():
            logger.debug("[sandbox stdout] %s", res.stdout.strip())
        if res.stderr.strip():
            logger.debug("[sandbox stderr] %s", res.stderr.strip())

        if res.returncode:
            raise RuntimeError(f"Failed to send command: {res.stderr.strip()}")

        return {
            "stdout": cmdline,
            "stderr": res.stderr.strip(),
            "returncode": res.returncode,
        }

    # ────────────────────────────────────────────── internals
    def _ensure_image(self) -> None:
        res = subprocess.run(
            ["docker", "images", "-q", "olive/sandbox:latest"],
            capture_output=True,
            text=True,
        )
        if not res.stdout.strip():
            logger.warning("Image not found – building…")
            self.build()

    def _hash_directory(self, path: Path) -> str:
        h = hashlib.sha1()
        for p in sorted(path.rglob("*")):
            if p.is_file():
                h.update(p.read_bytes())
        return h.hexdigest()

    def _disable_sandbox(self, prefs_path: Path) -> None:
        import yaml

        try:
            data = yaml.safe_load(prefs_path.read_text())
            data["sandbox"]["enabled"] = False
            prefs_path.write_text(yaml.safe_dump(data))
        except Exception as exc:  # noqa: BLE001
            logger.warning("Could not disable sandbox in snapshot prefs: %s", exc)

    def is_running(self) -> bool:
        if self.container_name is None:
            return False

        # inside the sandbox snapshot we disabled the sandbox flag,
        # so short‑circuit early to avoid docker probes & noisy logs
        if not prefs.is_sandbox_enabled():
            return False
        try:
            result = subprocess.run(
                ["docker", "ps", "-q", "-f", f"name={self.container_name}"],
                capture_output=True,
                text=True,
            )
            return bool(result.stdout.strip())
        except FileNotFoundError:
            # only warn on the host, stay silent inside the sandbox
            logger.debug("[sandbox] Docker binary not available.")
            return False

    def _render_dockerfile(self, template: Path) -> str:
        now = _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S %Z")
        banner = (
            "# ─────────────────────────────────────────\n"
            f"# 🚧 AUTOGENERATED DOCKERFILE – {now}\n"
            "# DO NOT EDIT — see Dockerfile.template\n"
            "# ─────────────────────────────────────────\n"
        )

        proj_root = env.get_project_root()
        olive_src = env.get_resource_path("olive").parent
        sbx_root = env.get_sandbox_root()

        snapshot_rel = (sbx_root / ".olive-snapshot").relative_to(proj_root)

        try:
            source_rel = olive_src.relative_to(proj_root)
        except ValueError:
            staging = sbx_root / "staging" / "olive"
            if staging.exists():
                shutil.rmtree(staging)
            shutil.copytree(olive_src, staging)
            source_rel = staging.relative_to(proj_root)

        body = (
            template.read_text()
            .replace("{{ olive_user }}", "olive")
            .replace("{{ olive_source_path }}", str(source_rel))
            .replace("{{ olive_prefs_snapshot }}", str(snapshot_rel))
        )
        return banner + "\n" + body.strip() + "\n"


# ──────────────────────────────────────────────────────────────
# Singleton instance & shutdown hooks
# ──────────────────────────────────────────────────────────────
sandbox = SandboxManager()
atexit.register(sandbox.stop)
signal.signal(signal.SIGTERM, lambda *_: sandbox.stop())
signal.signal(signal.SIGINT, lambda *_: sandbox.stop())
